/*
#선행처리기와 매크로


  -선행처리는 컴파일 이전의 처리를 의미합니다.
선행처리는 선행처리기에 의해서, 컴파일은 컴파일러에 의해서, 그리고 링크는 링커에 의해서 진행이 된다. 그런데 컴파일 이전에 선행처리의 과정을 거친다는 점에 주목해야 한다.
소스 파일-> 선행처리기-> 선행처리 거친 소스파일-> 컴파일러-> 오브젝트 파일-> 링커-> 실행파일

컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성된다. 선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다. 왜냐하면 소스파일의 형태가 그대로 유지되기 때문이다. 선행처리기가 하는 일은 지극히 단순하다. 
삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐인데, 여기서 말하는 수정이란, 단순 치환(substitution)의 형태를 띠는 경우가 대부분이다. 

다음은 간단한 선행처리 명령문이다.
#define PI 3.14

선행처리 명령문은 # 문자로 시작하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미클론을 붙이지 않는다. 그리고 이렇게 구성이 된 명령문은 선행처리기에게 다음과 같은 메시지를 전달한다.
"PI를 만나면 인정사정 볼 것 없이 3.14로 치환하여라."
따라서 위의 명령문이 삽입되어 있는 소스파일은 선행처리의 과정에서 다음과 같은 방식으로 변환된다.
선행처리 이전 소스파일                    선행처리 이후 소스파일
#define PI 3.14  ---명령문은 소멸--->     
int main(void)                          int main(void)
{                                       {
  ....                                    ....
  num= PI * 3.5;                          num= 3.14<-단순치환 * 3.5;  
  ....                                    ....
}                                       {

참고로 여기서 말하는 '선행처리'란, 컴파일 이전의 처리를 의미한다. 따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에, 선행처리기에 의해서 선행처리기의 과정을 거치게 된다고 이야기한다.

참고 #include <stdio.h>
자주해왔던 #include <stdio.h> 선언도 # 문자로 시작하는 선행처리 명령문이다. 이는 다음의 의미를 지닌다.
"stdio.h 파일의 내용을 이곳에 가져다 놓으세요."
따라서 여러분이 직접 stdio.h 파일을 열어서 그 안에 있는 내용을 옮겨놓아도 같은 효과를 기대할 수 있다. 


#대표적인 선행처리 명령문


  -#define: Object-like macro
#define PI 3.1415 <- 선행처리 명령문의 구성

#define: 지시자,  PI: 매크로,  3.1415: 매크로 몸체
위에서 보이듯 선행처리 명령문으니 기본적으로 세 부분으로 나뉘는데, #define을 가리켜 '지시자'라 한다. 선행처리기가 이 부분을 보고 프로그래머가 지시하는 바를 파악하기 때문에 지시지라 하는 것이다.
그리고 앞서 말했듯 #define 지시자는 선행처리기에게 다음과 같은 내용을 지시한다.
"이어서 등장하는 매크로를 마지막에 등장하는 매크로 몸체로 치환하라!"
#define 지시자 뒤에 등장하는 것을 가리켜 '매크로'라 하고, 그 뒤에 등장하는 것을 가리켜 '매크로 몸체(또는 대체 리스트)'라 한다. 따라서 위의 선행처리 명령문은 다음의 내용을 선행처리기에게 지시한다.
"매크로 PI를 매크로 몸체 3.1415로 전부 치환하라!"
결과적으로 PI라는 이름의 매크로는 그 자체로 상수 3.1415가 된 셈이다. 참고로 PI와 같은 매크로를 가리켜 '오브젝트와 유사한 매크로(object-like macro)' 또는 그냥 간단히 '매크로 상수'라 한다.

참고 오브젝트(object) 유사 매크로
오브젝트(object)라는 것은 그 자체로 '완전한 의미를 갖는 대상이나 사물'을 의미한다. 즉 위에서 정의한 매크로 PI는 그 자체로 3.1415라는 상수를 의미하기 때문에 '오브젝트와 유사한 매크로' 또는 '오브젝트와 비슷한 매크로'라 하는 것이다.

예제MacroConst.c
#include <stdio.h>
#define NAME "홍길동"
#define AGE 24
#define PRINT_ADDR puts("주소: 경기도 용인시\n");

int main()
{
  printf("이름: %s \n", NAME);
  printf("나이: %d \n", AGE);
  PRINT_ADDR;
  return 0;
}

참고로 매크로의 이름은 대문자로 정의하는 것이 일반적이다. 대문자로 정의함으로써 이 식별자가 매크로라는 사실을 부각시킬 수 있기 때문이다.

  -#define: Function-like macro
매크로는 매개변수가 존재하는 형태로도 정의할 수 있다. 그리고 이렇게 매개변수가 존재하는 매크로는 그 동작방식이 마치 함수와 유사하여 '함수와 유사한 매크로(function-like macro)'라 하는데, 줄여서 간단히 '매크로 함수'라 부르기도 한다.

다음은 매크로 함수의 예이다.
#define SQUARE(X) X*X

#define으로 시작을 하는 것은 매크로 상수의 정의와 동일하다. 그러나 매크로에 괄호가 등장함으로 인해 SQUARE(X) 패턴 등장 시 X*X 유형으로 바꿔라는 해석이 된다. 여기서 괄호 안에 존재하는 X는(X라는 이름이 중요한 것이 아니라, 괄호 안에 존재한다는 사실이 중요하다. X라는 이름은 바꿔도 된다) 정해지지 않은 임의의 값(또는 문장)을 의미한다.
예를 들어서 위의 매크로 정의 후에 다음과 같은 문장을 접했다고 가정하자.
SQUARE(123);
SQUARE(NUM);
그러면 선행처리 후에는 다음과 같이 변경된다.
123*123;
NUM*NUM;
함수의 호출과 유사하지 않은가? 참고로 이렇게 선행처리기에 의해서 변한되는 과정 자체를 가리켜 '매크로 확장(macro expansion)'이라한다. 

예제MacroFunction.c
#include <stdio.h>
#define SQUARE(X) X*X

int main()
{
  int num=20;
  //정상적 결과 출력
  printf("Square of num: %d \n", SQUARE(num));
  printf("SQUARE of -5: %d \n", SQUARE(-5));
  printf("SQUARE of 2.5: %g \n", SQUARE(2.5));

  //비정상적 결과 출력
  printf("Square of 3+2: %d \n", SQUARE(3+2));
  return 0;
}

위 예제를 통해 정의된 매크로가 함수처럼 동작함을 확인할 수 있다. 

  -잘못된 매크로 정의
위 예제에서 비정상적 결과 출력에서 다음 문장이 있다.

SQUARE(3+2)

매크로는 선행처리기에 의해 처리가 된다. 때문에 위의 문장은 단순히 다음과 같이 치환딜 뿐이다.

3+2*3+2

따라서 결과로 11이 출력되는 것은 당연한 일이다. 해결책은 SQUARE를 다음과 같이 구성하면 된다.

SQUARE((3+2))

그러면 다음과 같이 치환되어 문제는 해결된다.

(3+2)*(3+2)

그러나 이는 함수를 호출하는(매크로인 SQUARE를 그냥 함수라 하자) 사람에게 주의를 요하는 형태이기 때문에 안정적이지 못하다. 안정적인 형태가 되려면, 위 예제 SQUARE(3+2) 의 실행결과로 25가 출력되어야한다. 그래야 보다 함수다워진다.

  -매크로 몸체에 괄호를 마구마구 칩시다. 
예제 MacroFunction.c의 매크로를 다음과 같이 정의하면 정상적인 값의 출력을 기대할 수 있다.
#define SQUARE(X) (X)*(X)

SQUARE 매크로가 다음과 같이 치환되기 때문이다. 

(3+2)*(3+2)

그러나 여전히 문제가 남아있다.

int num=120 / SQUARE(2);

SQUARE(2)는 4이므로 변수 num이 30으로 초기화될 것을 기대할 수 있다. 그런데 실제로 초기화되는 값은 120이다. 왜냐하면 다음과 같이 치환되어 나눗셈이 먼저 진행되기 때문이다.

int num = 120 / (2) * (2);

따라서 이런 저런 문제를 모두 해결하기 위해서는 다음과 같은 형태로 매크로 함수를 정의해야 한다.

#define SQUARE(X) ((X)*(X))

이제 변수 num은 다음 식에 의해서 30으로 초기화된다.

int num = 120 / ((2)*(2));
이처럼 매크로 함수를 정의할 때에는 매크로 몸체부분을 구성하는 X와 같은 전달인자 하나하나에 괄호를 씌어줘야 함은 물론이고, 반드시 전체를 괄호로 한 번 더 묶어줘야 한다는 사실을 기억하자.

  -매크로를 두 줄에 걸쳐서 정의하려면요?
정의하는 매크로의 길이가 길어지는 경우에는 가독성을 높이기 위해서 두 줄에 걸쳐서 매크로를 정의하기도 한다. 그런데 다음과 같이 임의로 줄을 변경하면 에러가 발생한다. 기본적으로 매크로는 한 줄에 정의하는 것이 원칙이기 때문이다.
#define SQUARE(X)
        ((X)*(X))
따라서 매크로를 두 줄 이상에 걸쳐서 정의할 때에는 다음과 같이 \ 문자를 활용해서 줄이 바뀌었음을 명시해야 한다.
#define SQUARE(X)    \
        ((X)*(X))

  -매크로 정의 시, 먼저 정의된 매크로도 사용이 가능하다. 
  먼저 정의된 매크로는 뒤에서 매크로를 정의할 때 사용 가능하다. 
  예제MacroUseMacro.c
  #include <stdio.h>
  #define PI 3.14
  #define PRODUCT(X, Y)  ((X)*(Y))
  #define CIRCLE_AREA(R)  (PRODUCT((R), (R))*PI)

  int main()
  {
    double rad=2.1;
    printf("반지름 %g인 원의 넓이: %g \n", rad, CIRCLE_AREA(rad));
    return 0;
  }
  위 예제와 같이 먼저 정의된 매크로는 새로운 매크로를 정의하는데 사용이 가능하다. 
  
  -매크로 함수의 장점
함수를 매크로로 정의할 때 얻게 되는 장점들
1. 매크로 함수는 일반 함수에 비해 실행속도가 빠르다.
2. 자료형에 따라서 별도로 함수를 정의하지 않아도 된다.

실행속도가 빠른 이유부터 살펴보자면 일단 함수가 호출되면 다음 사항들이 동반된다.
1. 호출된 함수를 위한 스택 메모리의 할당
2. 실행위치의 이동과 매개변수로의 인자 전달
3. return 문에 의한 값의 변화

따라서 함수의 빈번한 호출은 실행속도의 저하로 이어진다. 반면 매크로 함수는 선행처리기에 의해 매크로 함수의 몸체부분이 매크로 함수의 호출 문장을 대신하기 때문에 위에서 언급한 사항들을 동반하지 않는다. 따라서 실행속도상의 이점이 있다.
매크로 함수의 두 번째 장점에 대해서 이야기할 차례이다. 전달인자의 자료형에 상관없이 제대로 치환됨을 알 수 있다. 이 모두가 매크로 함수의 호출문장이 매크로 함수의 몸체부분으로 단순히 치환되기 때문에 가능한 일이다.

  -매크로 함수의 단점
다음은 함수를 매크로로 정의할 때 고려해야 할 단점들이다.
1. 정의하기가 정말로 까다롭다.
2. 디버깅하기가 쉽지 않다.

첫 번째 단점을 느낄 수 있도록 아래 함수를 매크로의 형태로 정의해보면 부담스러울 것이다.
int DiffABS(int a, int b)
{
  if(a>b)
    return a-b;
  else 
    return b-a;
}

사고를 조금 달리해서 조건 연산자를 사용하면 조금은 쉽게 정의가 가능했을 것이다.
#define DIFF_ABS(X, Y)  ((X)>(Y) ? (X)-(Y)  :  (Y)-(X))

다음은 두 번째 단점을 보여주는 예제다.
예제MacroFunctionWeakness.c
#include <stdio.h>
#define DIFF_ABS(X, Y)  ((x)>(y)  ?  (x)-(y)  :  (y)-(x))
int main(void)
{
  printf("두 값의 차: %d \n", DIFF_ABS(5, 7));
  printf("두 값의 차: %d \n", DIFF_ABS(1.8, -1.4));
  return 0;
}

위 예제가 지니고 있는 문제점은 컴파일을 하면 다음과 같은 에러 메시지가 출력된다.
"x는 선언된 적이 없는 거에요."
"y는 선언된 적이 없는 거에요."

문제는 매크로에 있다. 정의된 매크로에서는 대문자 X, Y가 사용됐는데, 매크로 몸체부분에서는 소문자 x, y가 사용되었다. 따라서 선행처리 이후에 다음과 같이 각각 변경된다.
printf("두 값의 차: %d \n", ((x)>(y)  ?  (x)-(y)  :  (y)-(x)));
printf("두 값의 차: %d \n", ((x)>(y)  ?  (x)-(y)  :  (y)-(x)));
5와 7, 그리고 1.8과 -1.4로 채워져야 할 부분이 그냥 x, y로 남겨져 있다. 때문에 컴파일러는 x,y가 선언된 적 없는 식별자라고 에러 메시지를 출력하는 것이다. 이처럼 매크로를 잘못 정의할 경우, 에러 메시지는 선행처리 이전의 소스파일을 기준으로 출력되지 않고, 선행처리 이후의 소스파일을 기준으로 출력이 된다.
따라서 일반적인 에러 메시지보다 이해하기 힘들다는 단점이 있다.

  -그래서 이러한 함수들을 매크로로 정의하지요.
매크로 함수의 장점과 단점을 종합해보면, 다음의 특성을 지니는 함수들을 매크로의 형태로 정의하는 것이 옳다는 결론이 나온다.
1. 작은 크기의 함수
2. 호출의 빈도수가 높은 함수

우선 함수의 크기가 작아야 매크로의 형태로 정의하기가 편하고 에러의 발생 확률이 낮아서 디버깅에 대한 염려를 덜 수 있다. 그리고 호출의 빈도수가 높아야 매크로 함수가 가져다 주는 성능 향상의 이점도 최대한 누릴 수 있다.


#조건부 컴파일(Conditional Compilation)을 위한 매크로


  -if... #endif: 참이라면
if문이 조건부 실행을 위한 것이라면, #if...#endif는 조건부 코드 삽입을 위한 지시자이다.
예제if_endif.c
#include <stdio.h>
#define ADD 1
#define MIN 0

int main()
{
  int num1, num2;
  printf("두 개의 정수 입력: ");
  scanf("%d %d", &num1, &num2);

#if ADD // ADD가 참이라면
  printf("%d + %d = %d \n", num1, num2, num1+num2);
#endif

#if MIN // MIN이 참이라면
  printf("%d - %d = %d\n", num1, num2, num1-num2);
#endif

  return 0;
}

  -#ifdef...#endif: 정의되었다면
#if는 매크로가 참이냐 거짓이냐를 기준으로 동작한다면, #ifdef는 매크로가 정의되었느냐, 정의되지 않았느냐를 기준으로 동작한다.
예제ifdef_endif.c
#include <stdio.h>
//  #define ADD 1
#define MIN 0

int main()
{
  int num1, num2;
  printf("두 개의 정수 입력: ");
  scanf("%d %d", &num1, &num2);

#ifdef ADD // 매크로 ADD가 정의되었다면
  printf("%d + %d = %d \n", num1, num2, num1+num2);
#endif

#ifdef MIN // 매크로 MIN가 정의되었다면
  printf("%d - %d = %d\n", num1, num2, num1-num2);
#endif

  return 0;
}

매크로의 값은 중요하지 않기 때문에, 다음과 같이 매크로의 몸체를 생략해서 정의해도 된다.
#define ADD
#define MIN

그리고 이렇게 매크로가 정의되면 소스코드에 있는 ADD와 MIN은 선행처리 과정에서 공백으로 대체된다.(그냥 소멸된다)

  -#ifndef... #endif: 정의되지 않았다면
#ifdef문은 '매크로...이 정의되어 있다면'의 의미를 지니는 반면 #ifndef문은 '매크로 ...이 정의되어 있지 않다면'의 의미를 지닌다.
참고로 #ifndef의 중간에 있는 n은 not을 의미한다.

참고 #ifndef...#endif
이 매크로는 헤더파일의 중복포함을 막기 위해 주로 사용된다. 따라서 헤더파일의 디자인과 이야기할 때 사용되는 것을 보게 될 것이다.

  -#else의 삽입: #if, #ifdef, #ifndef에 해당
if문에 else를 추가할 수 있듯이 #if, #ifdef, #ifndef문에도 #else문을 추가할 수 있다. 
예제else_endif.c
#include <stdio.h>
#define HIT_NUM 5

int main()
{
#if HIT_NUM==5
  puts("매크로 상수 HIT_NUM은 현재 5입니다.");
#else
  puts("매크로 상수 HIT_NUM은 현재 5가 아닙니다.");
#endif

  return 0;
}

  -#elif의 삽입: #if에만 해당
if문에 else if를 여러 번 추가할 수 있듯이 #if문에도 #elif를 여러 번 추가할 수 있다. 그리고 else if의 끝을 else로 마무리 할 수 있듯이, #elif의 끝을 #else로 마무리할 수 있다.
예제elif_endif.c
#include <stdio.h>
#define HIT_NUM 7
int main()
{
#if HIT_NUM==5
  puts("매크로 상수 HIT_NUM은 현재 5입니다.");
#elif HIT_NUM==6
  puts("매크로 상수 HIT_NUM은 현재 6입니다.");
#elif HIT_NUM==7
  puts("매크로 상수 HIT_NUM은 현재 7입니다.");
#else
  puts("매크로 상수 HIT_NUM은 현재 5입니다.");
#endif
  return 0;
}
















*/
