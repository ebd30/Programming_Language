/*
#선행처리기와 매크로


  -선행처리는 컴파일 이전의 처리를 의미합니다.
선행처리는 선행처리기에 의해서, 컴파일은 컴파일러에 의해서, 그리고 링크는 링커에 의해서 진행이 된다. 그런데 컴파일 이전에 선행처리의 과정을 거친다는 점에 주목해야 한다.
소스 파일-> 선행처리기-> 선행처리 거친 소스파일-> 컴파일러-> 오브젝트 파일-> 링커-> 실행파일

컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성된다. 선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다. 왜냐하면 소스파일의 형태가 그대로 유지되기 때문이다. 선행처리기가 하는 일은 지극히 단순하다. 
삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐인데, 여기서 말하는 수정이란, 단순 치환(substitution)의 형태를 띠는 경우가 대부분이다. 

다음은 간단한 선행처리 명령문이다.
#define PI 3.14

선행처리 명령문은 # 문자로 시작하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미클론을 붙이지 않는다. 그리고 이렇게 구성이 된 명령문은 선행처리기에게 다음과 같은 메시지를 전달한다.
"PI를 만나면 인정사정 볼 것 없이 3.14로 치환하여라."
따라서 위의 명령문이 삽입되어 있는 소스파일은 선행처리의 과정에서 다음과 같은 방식으로 변환된다.
선행처리 이전 소스파일                    선행처리 이후 소스파일
#define PI 3.14  ---명령문은 소멸--->     
int main(void)                          int main(void)
{                                       {
  ....                                    ....
  num= PI * 3.5;                          num= 3.14<-단순치환 * 3.5;  
  ....                                    ....
}                                       {

참고로 여기서 말하는 '선행처리'란, 컴파일 이전의 처리를 의미한다. 따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에, 선행처리기에 의해서 선행처리기의 과정을 거치게 된다고 이야기한다.

참고 #include <stdio.h>
자주해왔던 #include <stdio.h> 선언도 # 문자로 시작하는 선행처리 명령문이다. 이는 다음의 의미를 지닌다.
"stdio.h 파일의 내용을 이곳에 가져다 놓으세요."
따라서 여러분이 직접 stdio.h 파일을 열어서 그 안에 있는 내용을 옮겨놓아도 같은 효과를 기대할 수 있다. 


#대표적인 선행처리 명령문







*/
