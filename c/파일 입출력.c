/*
#파일과 스트림(Stream), 그리고 기본적인 파일의 입출력
파일은 운영체제에 의해 관리가 되기 때문에 운영체제와 파일의 관계를 이해하는 것부터 시작할 필요가 있다.

  -저기 저 파일에 저장되어 있는 데이터를 읽고 싶어요.
프로그램상에서 저장돼있는 데이터를참조하길 원한다고(읽기 원한다고) 가정해보면 구현한 프로그램과 참조할 데이터가 저장돼있는 파일 사이에 데이터가 이동할 수 있는 다리를 놓는 일이 제일 먼저 해야 할 일이다.
이러한 데이터 이동의 경로가 되는 다리를 가리켜 '스트림(Stream)'이라 한다. 
프로그램과 파일 사이 스트림을 형성해야 데이터를 주고 받을 수 있다.

Program(code) <----stream----> Hard Disk in file.txt

파일로부터 데이터를 읽어 들일(파일에 데이터를 쓸) 기본적인 준비가 됐다라는 의미는 프로그램과 파일 사이에 스트림이 형성되었다고 이해하면 된다.
그런데 파일은 운영체제에 의해 그 구조가 결정되고 관리되는 대상이기에, 파일 뿐만 아니라 스트림의 형성도 운영체제의 몫임을 기억해야한다.

  -fopen 함수호출을 통한 팡리과의 스트림 형성과 FILE 구조체
#include <stdio.h>
FILE * fopen(const char * filename, const char * mode);
-> 성공 시 해당 파일의 FILE 구조체 변수의 주소 값, 실패 시 NULL 포인터 반환
fopen()함수의 첫 번째 인자로는 스트림을 형성할 파일의 이름, 두 번째 인자로는 형성할 스트림의 종류에 대한 정보를 문자열의 형태로 전달한다. 그러면 fopen함수는 해당 파일과의 스트림을 형성하고 스트림 정보를 FILE 구조체 변수에 담아서 그 변수의 주소 값을 반환한다.

fopen함수가 호출되면 FILE 구조체 변수가 생성된다.
생성된 FILE 구조체 변수에는 파일에 대한 정보가 담긴다.
FILE 구조체의 포인터는 사실상 파일을 가리키는 '지시자'의 역할을 한다.

  -입력 스트림과 출력 스트림의 생성
스트림은 '한 방향으로 흐르는 데이터의 흐름'을 의미한다. 때문에 스트림은 데이터를 파일로부터 읽어들이기 위한 '입력 스트림'과 데이터를 파일에 쓰기 위한 '출력 스트림'으로 구분된다.
fopen함수를 호출할 때 두 가지 인자.
첫 번째 인자 - 스트림을 형성할 파일의 이름
두 번째 인자 - 형성하고자 하는 스트림의 종류

출력 스트림의 형성을 요청하는 fopen 함수의 호출문
FILE * fp = fopen("data.txt", "wt"); // 출력 스트림의 형성, 파일 data.txt와 스트림을 형성하되 wt모드(쓰기 곧 출력 스트림)로 스트림을 형성해라라는 의미다.

입력 스트림의 형성을 요청하는 fopen 함수의 호출문
FILE * fp = fopen("data.txt", "rt"); // 입력 스트림의 형성, 파일 data.txt와 스트림을 형성하되 rt모드(읽기 곧 입력 스트림)로 스트림을 형성해라라는 의미다.

참고로 fopen함수의 호출을 통해 파일과의 스트림이 형성되었을 때 '파일이 개방(오픈)되었다'라고 표현하는 것이 일반적이다.

  -파일에 데이터를 써봅시다.
예제FirstFileWrite.c
#include <stdio.h>
int main()
{
  FILE * fp=fopen("data.txt", "wt");
  if(fp==NULL) {
    puts("파일 오픈 실패!");
    return -1;
  }

  fputc('A', fp);
  fputc('B', fp);
  fputc('C', fp);
  fclose(fp);
  return 0;
}

출력 스트림을 형성하는 경우에는 해당 파일이 생성된다. 따라서 파일 data.txt파일이 생성됨을 확인할 수 있을 것이다. 그런데 실행방법, 실행환경 및 설정에 따라 파일이 생성되는 위치가 달라진다. 
생성위치를 고정시키고 싶으면
FILE * fp = fopen("C:\\Project\\data.txt", "wt");
절대경로를 지정해 파일의 경로를 지정시켜주면 된다.예시로 경로를 지정한 것과 일치하게 드라이브랑 디렉토리가 생성되어있어야한다. 

  -스트림의 소멸을 요청하는 fclose함수
#include <stdio.h>
int fclose(FILE * stream);
-> 성공 시 0, 실패 시 EOF를 반환

fclose함수는 fopen함수의 반대 기능을 제공한다. stream을 해제하는, 파일을 닫는 함수이다.

fclose함수의 호출을 통해 파일을 닫아줘야 하는 이유
운영체제가 할당한 자원은 반환
버퍼링 되었던 데이터의 출력

함수의 호출을 통해 스트림의 형성을 요청하는 것은 사용자지만, 실제로 스트림을 형성하는 주체는 운영체제이다. 그리고 운영체제는 스트림의 형성을 위해 시스템의 자원(주로 메모리)을 할당한다. 그런데 이 자원은 파일을 닫아주지 않으면 할당된 채로 남아있게 되서 그만큼의 자원손실을 초래하기 때문에 파일의 사용이 끝나는 즉시 fclose함수를 호출해 자원을 반환해줄 필요가 있다.
두 번째 이유는 콘솔 스트림의 중간에 존재하는 입력버퍼와 출력버퍼를 기억하는가? 이와 마찬가지로 파일 스트림도 중간에 입력버퍼 출력버퍼가 있다. 
운영체제가 파일과 프로그램 사이 입출력 버퍼를 두어 성능의 향상을 도모하고 때문에 fputc와 같은 함수의 호출로 데이터를 파일로 전송한다고 해서 파일에 바로 저장되는 것이 아니라 일단 출력버퍼에 저장되고 운영체제가 정해놓은 버퍼링 방식에 따라 뒤늦게 파일에 저장된다.
그런데 이러한 버퍼링 방식에는 문제가 하나 있다. 예를 들어 'A'와 'B' 문자가 출력버퍼에 존재하는 상태에서(파일에 저장되기 직전의 상태에서) 컴퓨터의 전원이 꺼지면 문자 A, B는 파일에 저장되지 않는다. 그러나 fclose함수의 호출을 통해 파일을 닫아주면 출력버퍼에 저장되었던 데이터가 파일로 이동해 출력버퍼가 비워진다. 그 이후는 컴퓨터의 전원이 꺼져도 팡리에 저장된 데이터는 소멸되지 않는다. 때문에 사용이 끝난 파일은 곧바로 fclose함수를 호출해주는 것이 좋다.

  -Chapter21 에서 호출한 적 있는 fflush함수
#include <stdio.h>
int fflush(FILE * stream);
-> 함수호출 성공 시 0, 실패 시 EOF 반환

입출력 버퍼를 비우는 것과 관련해 설명할 사실
1. 출력버퍼를 비운다는 것은 출력버퍼에 저장된 데이터를 목적지로 전송한다는 의미
2. 입력버퍼를 비운다는 것은 입력버퍼에 저장된 데이터를 소멸시킨다는 의미
3. fflush함수는 출력버퍼를 비우는 함수다.
4. fflush함수는 입력버퍼를 대상으로 호출할 수 없다.

위 내용은 파일 스트림에도 그대로 적용된다. 다음과 같이 파일의 출력버퍼를 비울 수 있다.
int main()
{
  FILE * fp=fopen("data.txt", "wt"); // 출력 스트림 형성
  ....
  fflush(fp); // 출력버퍼 비워라는 요청
  ....
}
이렇듯 fflush 함수는 출력버퍼를 위한 함수다. 파일스트림의 입력버퍼는 어떻게 지우냐고 질문할 수 있다. 그런데 파일 스트림의 입력버퍼를 비우는 함수는 필요가 없다. 파일에 저장된 데이터는 원할 때 언제든지 읽을 수 있을 뿐 아니라(읽혀진 데이터는 입력버퍼에서 지워진다.), 파일대상의 입력버퍼를 비워야만 하는 상황이라는 것이 특별히 존재하지 않기 때문이다.

  -파일로부터 데이터를 읽어 봅시다.
예제FirstFileRead.c
#include <stdio.h>
int main()
{
  int ch;
  FILE * fp=fopen("data.txt" , "rt");
  if(fp==NULL) {
    puts("파일 열기 실패!");
    return -1;
  }
  for(i=0; i<3; i++)
  {
    ch=fgetc(fp);
    printf("%c\n", ch);
  }
  fclose(fp);
  return 0;
}


#파일의 개방 모드(Mode)
앞서 fopen함수의 두 번째 인자로 "rt", "wt"를 전달해 입력, 출력 스트림을 형성했었다. 하지만 형성할 수 있는 스트림의 종류는 다양하다. 
기본적으로 두 가지 기준을 통해 스트림을 구분하게 된다.
기준1 - 읽기 위한 스트림이냐? 쓰기 위한 스트림이냐?
기준2 - 텍스트 데이터를 읽기 위한 스트림이냐? 바이너리 데이터를 읽기 위한 스트림이냐?

  -스트림을 구분하는 기준1: 읽기 위한 스트림? 쓰기 위한 스트림?
스트림을 구분하는 기준은 두 가지인데, 이 중 데이터의 이동방향을 기준으로 다음과 같이 네 가지로 구분할 수 있다.
데이터 READ 스트림(읽기만 가능)
데이터 WRITE 스트림(쓰기만 가능)
데이터 APPEND 스트림(쓰되 덧붙여 쓰기만 가능)
데이터 READ/WRITE 스트림(읽기, 쓰기 모두 가능)

그러나 C언어는 이를 바탕으로 총 6가지로 스트림을 세분화한다. 
모드(mode) - 스트림의 성격 - 파일이 없으면?
r - 읽기 가능 - 에러
w - 쓰기 가능 - 생성
a - 파일의 끝에 덧붙여 쓰기 가능 - 생성
r+ - 읽기/쓰기 가능 - 에러
w+ - 읽기/쓰기 가능 - 생성
a+ - 읽기/덧붙여 쓰기 가능 - 생성

필요로 하는 스트림의 특성과 일치하는 '파일의 개방 모드(Mode)'를 선택하면 된다. fopen함수의 두 번째 인자가 된다.
다음 두 가지를 기억하라
모드의 +는 읽기, 쓰기가 모두 가능한 스트림의 형성을 의미한다.
모드의 a는 쓰기가 가능한 스트림을 형성하는데, 여기서 말하는 쓰기는 덧붙이기이다.

웬만하면 r, w, a 중에서 선택하라
파일의 개방모드 중 r+, w+, a+는 읽기와 쓰기가 동시에 가능하여 더 좋다고 생각할 수 있다. 그러나 이러한 모드를 기반으로 작업하는 경우 읽기에서 쓰기, 그리고 쓰기에서 읽기로 작업을 변경할 때마다 메모리 버퍼를 비워줘야 하는 등의 불편함과 더불어 잘못된 사용의 위험성도 따른다.


  
  



*/
